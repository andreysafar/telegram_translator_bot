import os
import logging
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, 
    CallbackQueryHandler, ContextTypes, filters
)
from telegram.constants import ParseMode

from config import *
from user_storage import UserStorage
from openrouter_service import OpenRouterService
from language_detector import LanguageDetector

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class TelegramTranslatorBot:
    def __init__(self):
        self.user_storage = UserStorage()
        self.openrouter_service = OpenRouterService()
        self.language_detector = LanguageDetector()
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user = update.effective_user
        
        # Create or get user settings
        user_settings = self.user_storage.get_user(user.id)
        if user.username:
            self.user_storage.update_user(user.id, username=user.username)
        
        welcome_message = f"""
ü§ñ –ü—Ä–∏–≤–µ—Ç, {user.first_name}!

–Ø –±–æ—Ç-–ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–æ–≤. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é –ø–µ—Ä–µ–≤–æ–¥—ã –º–µ–∂–¥—É:
üá∑üá∫ –†—É—Å—Å–∫–∏–º
üáπüá≠ –¢–∞–π—Å–∫–∏–º  
üá¨üáß –ê–Ω–≥–ª–∏–π—Å–∫–∏–º

**–ö–∞–∫ —è —Ä–∞–±–æ—Ç–∞—é:**
1. –ü–æ–ª—É—á–∞—é —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –æ–ø—Ä–µ–¥–µ–ª—è—é —è–∑—ã–∫
2. –ü–µ—Ä–µ–≤–æ–∂—É –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
3. –ü–µ—Ä–µ–≤–æ–∂—É –Ω–∞ —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫
4. –î–µ–ª–∞—é –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –æ–±—Ä–∞—Ç–Ω–æ

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é:**
üìù –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è

**–ö–æ–º–∞–Ω–¥—ã:**
/config - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–∏ –∏ —è–∑—ã–∫–∞
/help - —Å–ø—Ä–∞–≤–∫–∞

–î–æ–±–∞–≤—å—Ç–µ –º–µ–Ω—è –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç –∏ —è –±—É–¥—É –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è!
        """
        
        await update.message.reply_text(welcome_message)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_text = """
üÜò **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –±–æ—Ç—É-–ø–µ—Ä–µ–≤–æ–¥—á–∏–∫—É**

**–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:**
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä—É—Å—Å–∫–æ–≥–æ, —Ç–∞–π—Å–∫–æ–≥–æ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–æ–≤
‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
‚Ä¢ –¢—Ä–µ—Ö—ç—Ç–∞–ø–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –ø–µ—Ä–µ–≤–æ–¥–∞ —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –∫–∞—á–µ—Å—Ç–≤–∞

**–ö–æ–º–∞–Ω–¥—ã:**
/start - –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ
/config - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–∏ –ø–µ—Ä–µ–≤–æ–¥–∞ –∏ —è–∑—ã–∫–∞
/help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞

**–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–µ—Ä–µ–≤–æ–¥:**
1. üì• –ü–æ–ª—É—á–∞—é –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
2. üîç –û–ø—Ä–µ–¥–µ–ª—è—é —è–∑—ã–∫ (—Ä—É—Å—Å–∫–∏–π/—Ç–∞–π—Å–∫–∏–π/–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)
3. üîÑ –ü–µ—Ä–µ–≤–æ–∂—É —á–µ—Ä–µ–∑ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –Ω–∞ —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫
4. ‚úÖ –î–µ–ª–∞—é –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
5. üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç—Ä–µ–º—è –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏

**–î–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π:**
1. üé§ –ü—Ä–µ–æ–±—Ä–∞–∑—É—é —Ä–µ—á—å –≤ —Ç–µ–∫—Å—Ç
2. üìù –ü–æ–∫–∞–∑—ã–≤–∞—é —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
3. üîÑ –ü—Ä–∏–º–µ–Ω—è—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –ø–µ—Ä–µ–≤–æ–¥–∞

–ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤—å—Ç–µ –º–µ–Ω—è –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç –∏ –Ω–∞—á–Ω–∏—Ç–µ –æ–±—â–∞—Ç—å—Å—è!
        """
        
        await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)
    
    async def config_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /config command"""
        user = update.effective_user
        user_settings = self.user_storage.get_user(user.id)
        
        keyboard = [
            [InlineKeyboardButton("üåç –Ø–∑—ã–∫ –Ω–æ—Å–∏—Ç–µ–ª—è", callback_data="config_language")],
            [InlineKeyboardButton("ü§ñ –ú–æ–¥–µ–ª—å –ø–µ—Ä–µ–≤–æ–¥–∞", callback_data="config_translation_model")],
            [InlineKeyboardButton("üé§ –ú–æ–¥–µ–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏", callback_data="config_stt_model")],
            [InlineKeyboardButton("üìä –¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="config_show")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "‚öôÔ∏è **–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞**\n\n–í—ã–±–µ—Ä–∏—Ç–µ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    
    async def handle_config_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle config callback queries"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        user_settings = self.user_storage.get_user(user_id)
        
        if query.data == "config_language":
            keyboard = []
            for lang_code, lang_name in SUPPORTED_LANGUAGES.items():
                emoji = "‚úÖ" if user_settings['native_language'] == lang_code else ""
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {lang_name}", 
                    callback_data=f"set_language_{lang_code}"
                )])
            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="config_back")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "üåç **–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ä–æ–¥–Ω–æ–π —è–∑—ã–∫:**\n\n–≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç —Ç–æ—á–Ω–µ–µ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞.",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data == "config_translation_model":
            keyboard = []
            for model in AVAILABLE_TRANSLATION_MODELS:
                emoji = "‚úÖ" if user_settings['translation_model'] == model else ""
                model_name = model.split('/')[-1]  # Get model name without provider
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {model_name}", 
                    callback_data=f"set_trans_model_{model.replace('/', '_')}"
                )])
            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="config_back")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "ü§ñ **–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞:**",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data == "config_stt_model":
            keyboard = []
            for model in AVAILABLE_STT_MODELS:
                emoji = "‚úÖ" if user_settings['stt_model'] == model else ""
                model_name = model.split('/')[-1]
                keyboard.append([InlineKeyboardButton(
                    f"{emoji} {model_name}", 
                    callback_data=f"set_stt_model_{model.replace('/', '_')}"
                )])
            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="config_back")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                "üé§ **–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏:**",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data == "config_show":
            settings_text = f"""
üìä **–í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:**

üåç **–†–æ–¥–Ω–æ–π —è–∑—ã–∫:** {SUPPORTED_LANGUAGES[user_settings['native_language']]}
ü§ñ **–ú–æ–¥–µ–ª—å –ø–µ—Ä–µ–≤–æ–¥–∞:** {user_settings['translation_model'].split('/')[-1]}
üé§ **–ú–æ–¥–µ–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è:** {user_settings['stt_model'].split('/')[-1]}
            """
            
            keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="config_back")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                settings_text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data == "config_back":
            await self.config_command(update, context)
        
        elif query.data.startswith("set_language_"):
            lang_code = query.data.replace("set_language_", "")
            self.user_storage.set_native_language(user_id, lang_code)
            
            await query.edit_message_text(
                f"‚úÖ –†–æ–¥–Ω–æ–π —è–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {SUPPORTED_LANGUAGES[lang_code]}",
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data.startswith("set_trans_model_"):
            model = query.data.replace("set_trans_model_", "").replace("_", "/")
            self.user_storage.set_translation_model(user_id, model)
            
            await query.edit_message_text(
                f"‚úÖ –ú–æ–¥–µ–ª—å –ø–µ—Ä–µ–≤–æ–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {model.split('/')[-1]}",
                parse_mode=ParseMode.MARKDOWN
            )
        
        elif query.data.startswith("set_stt_model_"):
            model = query.data.replace("set_stt_model_", "").replace("_", "/")
            self.user_storage.set_stt_model(user_id, model)
            
            await query.edit_message_text(
                f"‚úÖ –ú–æ–¥–µ–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {model.split('/')[-1]}",
                parse_mode=ParseMode.MARKDOWN
            )
    
    async def handle_text_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle regular text messages"""
        if not update.message or not update.message.text:
            return
        
        user = update.effective_user
        text = update.message.text
        
        # Skip if message is a command
        if text.startswith('/'):
            return
        
        # Get user settings
        user_settings = self.user_storage.get_user(user.id)
        
        # Detect language
        source_language = self.language_detector.detect_language(
            text, user_settings['native_language']
        )
        
        # Determine target language
        target_language = self.language_detector.determine_target_language(
            source_language, user_settings['native_language']
        )
        
        # Skip translation if source and target are the same
        if source_language == target_language:
            return
        
        # Show typing indicator
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id,
            action="typing"
        )
        
        # Perform translation
        translation_result = self.openrouter_service.perform_translation_chain(
            text=text,
            source_lang=source_language,
            target_lang=target_language,
            translation_model=user_settings['translation_model']
        )
        
        if translation_result.get('error'):
            await update.message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {translation_result['error']}"
            )
            return
        
        # Format and send translation result
        await self.send_translation_result(update, translation_result)
    
    async def handle_voice_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle voice messages"""
        if not update.message or not update.message.voice:
            return
        
        user = update.effective_user
        user_settings = self.user_storage.get_user(user.id)
        
        try:
            # Show typing indicator
            await context.bot.send_chat_action(
                chat_id=update.effective_chat.id,
                action="typing"
            )
            
            # Download voice file
            voice_file = await update.message.voice.get_file()
            voice_path = f"voice_{user.id}_{update.message.message_id}.ogg"
            await voice_file.download_to_drive(voice_path)
            
            # Convert to text
            recognized_text = self.openrouter_service.speech_to_text(
                voice_path, user_settings['stt_model']
            )
            
            # Clean up file
            if os.path.exists(voice_path):
                os.remove(voice_path)
            
            if not recognized_text:
                await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å")
                return
            
            # Send recognized text
            await update.message.reply_text(
                f"üé§ **–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:**\n_{recognized_text}_",
                parse_mode=ParseMode.MARKDOWN
            )
            
            # Detect language and translate
            source_language = self.language_detector.detect_language(
                recognized_text, user_settings['native_language']
            )
            
            target_language = self.language_detector.determine_target_language(
                source_language, user_settings['native_language']
            )
            
            if source_language == target_language:
                return
            
            # Perform translation
            translation_result = self.openrouter_service.perform_translation_chain(
                text=recognized_text,
                source_lang=source_language,
                target_lang=target_language,
                translation_model=user_settings['translation_model']
            )
            
            if translation_result.get('error'):
                await update.message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {translation_result['error']}"
                )
                return
            
            # Format and send translation result
            await self.send_translation_result(update, translation_result)
            
        except Exception as e:
            logger.error(f"Voice processing error: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è")
    
    async def send_translation_result(self, update: Update, result: dict):
        """Format and send translation result"""
        source_lang_name = self.language_detector.get_language_name(result['source_language'])
        target_lang_name = self.language_detector.get_language_name(result['target_language'])
        
        # Create formatted message
        message_parts = [
            f"üîÑ **–ü–µ—Ä–µ–≤–æ–¥** ({source_lang_name} ‚Üí {target_lang_name})",
            "",
            f"üìù **–û—Ä–∏–≥–∏–Ω–∞–ª ({source_lang_name}):**",
            f"_{result['original']}_",
            ""
        ]
        
        if result['english_translation'] and result['source_language'] != 'en':
            message_parts.extend([
                f"üá¨üáß **–ê–Ω–≥–ª–∏–π—Å–∫–∏–π:**",
                f"_{result['english_translation']}_",
                ""
            ])
        
        message_parts.extend([
            f"üéØ **–ü–µ—Ä–µ–≤–æ–¥ ({target_lang_name}):**",
            f"**{result['final_translation']}**",
            ""
        ])
        
        if result['control_translation']:
            message_parts.extend([
                f"‚úÖ **–ö–æ–Ω—Ç—Ä–æ–ª—å ({source_lang_name}):**",
                f"_{result['control_translation']}_"
            ])
        
        formatted_message = "\n".join(message_parts)
        
        await update.message.reply_text(
            formatted_message,
            parse_mode=ParseMode.MARKDOWN,
            reply_to_message_id=update.message.message_id
        )
    
    def create_application(self) -> Application:
        """Create and configure the Telegram application"""
        application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        
        # Add handlers
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CommandHandler("help", self.help_command))
        application.add_handler(CommandHandler("config", self.config_command))
        
        # Callback query handler for config
        application.add_handler(CallbackQueryHandler(self.handle_config_callback))
        
        # Text message handler (excluding commands)
        application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_text_message)
        )
        
        # Voice message handler
        application.add_handler(
            MessageHandler(filters.VOICE, self.handle_voice_message)
        )
        
        return application
    
    async def run(self):
        """Run the bot"""
        application = self.create_application()
        
        logger.info("Starting Telegram Translator Bot...")
        
        # Start the bot
        await application.initialize()
        await application.start()
        await application.updater.start_polling()
        
        logger.info("Bot is running. Press Ctrl+C to stop.")
        
        try:
            # Keep the bot running
            await asyncio.Event().wait()
        except KeyboardInterrupt:
            logger.info("Stopping bot...")
        finally:
            await application.updater.stop()
            await application.stop()
            await application.shutdown()

# Function to run the bot
async def main():
    bot = TelegramTranslatorBot()
    await bot.run()

if __name__ == "__main__":
    asyncio.run(main())

